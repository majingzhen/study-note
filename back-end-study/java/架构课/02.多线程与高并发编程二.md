# 多线程与高并发编程二

## Volatile

两个特性：保证线程可见性、禁止指令重排序

### 保证线程可见性

在内存中堆内存是共享内存，不同的线程有不同的工作空间，当我们创建一个变量的时候，如果某个线程用到了这个变量，那么会往线程的工作空间内copy一份，线程拿到变量后，如果堆内存的变量值发生改变后，不确定什么时候线程会再次去堆内存中取新值。

这个就是线程之间的不可见。

加了 volatile 之后，对其值进行改变，能确保其他线程能立刻知道。

MESI：CPU的缓存一致性协议，不同的线程运行在不同的CPU上，当你一个线程的值修改之后，另一个线程不一定马上知道，java的线程之间的可见性，实际上要靠CPU的缓存一致性协议才能保证。

### 禁止指令重排序

也和CPU有关，以前的CPU是顺序执行指令，现在的CPU是并发执行指令，也叫流水线

这就要求编译器可以做到指令重排序，例如：a = 4; b = 5;   它有可能先执行 b = 5, 后执行 a = 4

面试题：单例模式的双重检查可以解决懒汉式的线程安全问题，这种情况下还需要加volatile吗？

需要，但部分情况下都不会有问题，但是问题有可能会出现在指令重排序上。

注：new 对象的过程分三步，第一步申请内存，第二步初始化，第三部赋值，如果不加volatile，可能会造成第二步和第三步顺序调整，造成数据异常，会拿到一个半初始化的对象数据

volatile 并不能保证多个线程共同修改running变量时所带来的不一致问题，他不能保证数据的原子性，也就是说volatile不能代替synchronized

## 锁优化

同步代码块的语句越少越好

优化分为细化和粗化，只锁定需要上锁的代码，是锁的细化，如果一个大的代码段里有很多的小锁，这时还不如给整个代码段加锁，这是锁的粗化。

锁定某个对象o, 如果o的属性发生了变化，不影响锁的使用。但是如果o变成了另外一个对象，则锁定的对象发生改变。应该避免将锁定对象的引用变成另外的对象

解决方法：在对象o上 加上final关键字，不让它进行改变

## CAS(无锁优化 乐观锁 自旋)

Compare And Set/Swap

cas相当于一个方法，cas(V,E,New)， V是需要修改的对象，E是期望的值，New是需要修改的值，当V == E的时候，那么V = New，当V != E的时候，就证明V的值已经被其他线程修改过了，这时候就要重新获取V的值来再次进行cas操作

CAS是CPU原语支持，判断V是否等于E的时候是不能被打断的

解决同样问题的更高效的方法，使用AtomicXXX类
AtomicXXX类本身方法都是原子性的，但不能保证多个方法连续调用是原子性的

### ABA问题

ABA会产生的问题，如果这个对象是int等基础类型是不会有什么问题，如果是一个Object对象，对象A 指向对象B，对象B指向对象C，现在将对象A指向对象C，然后修改了对象C的值之后，又将对象A指回对象B，这个时候对象B指向的对象C，里边的值已经发生了变化。

现在有一个对象o o = 1， 需要把o的值变为2，去执行cas操作，掉用了 cas(o, 1, 2)，在这个过程中另一个线程把o改为了2，然后又改回了1，这就是ABA问题，如果想解决的话，可以加version(版本号)，每次修改值，version+1，后边检查时一起进行判断

### UnSafe

所有的Cas操作都是 compareAndSetObject  底部都是由UnSafe这个类来完成的

UnSafe是单例模式的，直接操作jvm虚拟机的内存

